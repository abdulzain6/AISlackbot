import base64
import re
import string
import redis
import requests

from zlib import compress
from typing import Dict, Optional, Any, Union
from .tool_maker import ToolMaker, ToolConfig
from langchain_core.tools import BaseTool, tool
from sqlalchemy.orm import Session
from graphviz import Source
from ...lib.integrations.auth.oauth_handler import OAuthClient
from ...lib.platforms.platform_helper import PlatformHelper


plantuml_alphabet = (
    string.digits + string.ascii_uppercase + string.ascii_lowercase + "-_"
)
base64_alphabet = string.ascii_uppercase + string.ascii_lowercase + string.digits + "+/"
b64_to_plantuml = bytes.maketrans(
    base64_alphabet.encode("utf-8"), plantuml_alphabet.encode("utf-8")
)


class PlantUMLHTTPError(Exception):
    def __init__(self, response, content, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.response = response
        self.content = content

    def __str__(self):
        return str(self.content)


def deflate_and_encode(plantuml_text):
    """zlib compress the plantuml text and encode it for the plantuml server."""
    zlibbed_str = compress(plantuml_text.encode("utf-8"))
    compressed_string = zlibbed_str[2:-4]
    return (
        base64.b64encode(compressed_string).translate(b64_to_plantuml).decode("utf-8")
    )


class PlantUML:
    def __init__(
        self,
        url: str = "http://www.plantuml.com/plantuml/",
        basic_auth: Optional[Dict[str, str]] = None,
        form_auth: Optional[Dict[str, Union[str, Dict[str, str]]]] = None,
        request_opts: Optional[Dict[str, Any]] = None,
    ) -> None:
        """
        Initializes the PlantUML client for handling connections to the server.

        :param url: The base URL of the PlantUML server (default: "http://www.plantuml.com/plantuml/").
        :param basic_auth: Dictionary containing 'username' and 'password' for basic authentication.
        :param form_auth: Dictionary with 'url' for login and 'body' for form elements required to log in.
        :param request_opts: Optional request options to pass when making HTTP requests.
        """
        self.url = url
        self.request_opts = request_opts or {}
        self.auth_type = (
            "basic_auth" if basic_auth else "form_auth" if form_auth else None
        )
        self.auth = basic_auth or form_auth
        self.session = requests.Session()
        if self.auth_type == "basic_auth":
            self._setup_basic_auth()
        elif self.auth_type == "form_auth":
            self._setup_form_auth()

    def _setup_basic_auth(self) -> None:
        """
        Configures basic authentication using the provided username and password.
        """
        if not self.auth:
            raise ValueError("Basic authentication credentials must be provided.")
        username = self.auth.get("username")
        password = self.auth.get("password")
        if not username or not password:
            raise ValueError(
                "Both 'username' and 'password' must be provided for basic_auth."
            )
        self.session.auth = (username, password)

    def _setup_form_auth(self) -> None:
        """
        Configures form-based authentication by sending a login request to the server.
        """
        if not self.auth:
            raise ValueError("Form authentication credentials must be provided.")

        login_url = self.auth.get("url")
        body = self.auth.get("body")
        headers = self.auth.get(
            "headers", {"Content-type": "application/x-www-form-urlencoded"}
        )
        method = self.auth.get("method", "POST")

        if not login_url:
            raise ValueError("The 'url' field must be provided for form_auth.")
        if not isinstance(body, dict):
            raise ValueError("The 'body' field in form_auth must be a dictionary.")

        try:
            response = self.session.request(
                method=method, url=login_url, headers=headers, data=body
            )
            response.raise_for_status()
        except requests.RequestException as e:
            raise ValueError(f"HTTP request error: {e}")

        # Add cookies to session from the form_auth response
        if "set-cookie" in response.headers:
            self.session.headers.update({"Cookie": response.headers["set-cookie"]})

    def get_url(self, plantuml_text: str, output_format: str = "png") -> str:
        """
        Constructs the full URL pointing to the image generated by the PlantUML server.

        :param plantuml_text: The PlantUML markup to render.
        :param output_format: The format of the desired output ('png' or 'svg').
        :return: The full URL for the image on the PlantUML server.
        """
        if output_format not in {"png", "svg", "txt"}:
            raise ValueError("Invalid format. Supported formats are 'png' and 'svg'.")

        encoded_text = deflate_and_encode(plantuml_text)
        return f"{self.url}{output_format}/{encoded_text}"

    def processes(self, plantuml_text: str, output_format: str = "png") -> bytes:
        """
        Processes the PlantUML markup and retrieves the raw image data in the desired format.

        :param plantuml_text: The PlantUML markup to render.
        :param output_format: The format of the desired output ('png' or 'svg').
        :return: The raw image data in the chosen format.
        :raises PlantUMLHTTPError: If the server returns an error response.
        """
        image_url = self.get_url(plantuml_text, output_format)
        try:
            response = self._make_request(image_url)
        except requests.RequestException as e:
            raise ValueError(f"HTTP request error: {e}")

        if response.status_code == 200:
            return response.content

        # If the image request fails, attempt to retrieve the error as ASCII response.
        return self._retrieve_ascii_error(plantuml_text)

    def _make_request(self, url: str) -> requests.Response:
        """
        Sends a standardized HTTP request to the given URL.

        :param url: The URL to request.
        :return: The HTTP response.
        """
        response = self.session.get(url, **self.request_opts)
        response.raise_for_status()
        return response

    def _retrieve_ascii_error(self, plantuml_text: str) -> bytes:
        """
        Retrieves the error response as ASCII text.

        :param plantuml_text: The PlantUML markup to render.
        :return: The ASCII error message content.
        :raises PlantUMLHTTPError: If the ASCII response request also fails.
        """
        ascii_url = self.get_url(plantuml_text, "txt")
        try:
            response = self._make_request(ascii_url)
            raise PlantUMLHTTPError(response, response.text)
        except requests.RequestException as e:
            raise ValueError(f"HTTP request error while fetching ASCII error: {e}")


class AIPlantUMLGenerator(ToolMaker):
    REQUESTED_OAUTH_INTEGRATIONS: list[str] = []
    DESCRIPTION: str = """Used to make diagrams including uml, graphs etc"""

    def __init__(
        self,
        tool_config: ToolConfig,
        platform_helper: PlatformHelper,
        oauth_integrations: dict[str, OAuthClient],
        session: Session,
        redis_client: redis.Redis,
    ):
        self.redis_client = redis_client
        self.session = session
        self.platform_helper = platform_helper

    def create_ai_tools(self) -> list[BaseTool]:
        @tool
        def generate_uml_diagram(plantuml_text: str, output_format: str = "png") -> str:
            """
            Generates a UML diagram from PlantUML text, supports SVG and PNG formats.
            """
            plantuml = PlantUML()
            plantuml_text = self.extract_code(plantuml_text)
            try:
                if output_format in {"svg", "png"}:
                    image_bytes = plantuml.processes(plantuml_text, output_format=output_format)
                else:
                    raise ValueError("Unsupported output format. Use 'svg' or 'png'.")
                
                self.platform_helper.send_file(file=image_bytes, title="UML Diagram")
                return "UML diagram has been generated and the user can see it. Tell him to see chat"
            except Exception as e:
                return f"Error generating UML diagram: {e}"
            
        @tool
        def make_graphviz_graph(dot_code: str, output_format: str = "png") -> str:
            """
            Creates a diagram from DOT code using Graphviz, supports PNG and other formats.
            """
            dot_code = self.extract_code(dot_code)
            dot = Source(dot_code)
            file_bytes = dot.pipe(format=output_format)
            self.platform_helper.send_file(file=file_bytes, title="Graphviz Diagram")
            return "Graphviz diagram has been generated and the user can see it. Do not send any URLs."


        return [generate_uml_diagram, make_graphviz_graph]

    @staticmethod
    def extract_code(markdown_text: str) -> str:
        """
        Extracts content from code blocks in markdown.
        Supports blocks that use triple backticks with optional language identifiers.
        """
        # Enhanced regex to handle nested content or special characters
        code_blocks = re.findall(r"```[\w\s]*\n(.*?)```", markdown_text, re.DOTALL)
        if code_blocks:
            # Join multiple code blocks with a newline
            return "\n\n".join(code_blocks).strip()
        return markdown_text  # Return original if no code blocks are found
